================================================================================
FreeRTOS RISC-V Debugging Log
================================================================================

CURRENT STATUS: System crashes after xPortStartFirstTask() - mret goes to address 0

================================================================================
THINGS WE HAVE TRIED:
================================================================================

1. [COMPLETED] Increased task stack sizes from 256 to 512 words
   - Result: DID NOT FIX - still crashes
   - Output still shows mepc=0x00000004 after timer interrupt (CPU was at 0x0)

2. [COMPLETED] Fixed 7 hardware bugs in cpu_core.v:
   - Bug 1: mret was adding +4 to mepc (fixed: branch_target_mret = csr_mepc)
   - Bug 2: mepc saved id_pc instead of id_pc+4 for interrupts
   - Bug 3: mret CSR update conflicted with trap_take
   - Bug 4: Interrupts not blocked during system instructions
   - Bug 5: ebreak not handled properly
   - Bug 6: Register writes not cancelled during trap flush
   - Bug 7: Memory writes not cancelled during trap flush

3. [COMPLETED] Fixed xPortStartFirstTask to use MPIE instead of MIE
   - Changed from (1<<3) to (1<<7) in mstatus before mret
   - Ensures interrupts enable atomically via mret

4. [COMPLETED] Reverted to srv32-style simplified port
   - Removed complex official FreeRTOS port
   - Used minimal trap handler matching srv32

================================================================================
CURRENT OBSERVATIONS (Dec 5, 2025):
================================================================================

Output pattern shows:
1. Multiple ecalls during FreeRTOS initialization:
   - ecall at 0x351c and 0x3520 (alternating, probably taskYIELD in kernel)
   - These happen during pvPortMalloc/task creation

2. After xPortStartFirstTask():
   - ecall at 0x000002c4 <-- SUSPICIOUS! Very early address
   - Then timer interrupt with mepc=0x00000004 (CPU was at address 0!)

3. mtvec values are inconsistent across reboots:
   - First boot: mtvec=0x00000004 (WRONG - not aligned to trap handler!)
   - Later: mtvec=0x0000673C (seems OK)
   - Later: mtvec=0x000000A0 (this is _early_trap_handler)

KEY INSIGHT: The ecall at 0x000002c4 happens AFTER xPortStartFirstTask prints
"Calling xPortStartFirstTask()...". This means:
- xPortStartFirstTask did mret to mepc
- mepc must have been 0x000002c4 (or near it)
- 0x000002c4 is a very early address - NOT a task entry point!

================================================================================
HYPOTHESIS:
================================================================================

The first task's saved mepc (at stack offset 0) is NOT the task entry point.
Either:
A) pxPortInitialiseStack is storing wrong value
B) FreeRTOS is calling pxPortInitialiseStack with wrong parameters
C) The stack got corrupted between initialization and first task start

================================================================================
NEW FINDING (Dec 5, 2025 - Latest Run):
================================================================================

BIG CLUE: mtvec shows WRONG value on first boot!
- First boot: mtvec=0x00000004 (WRONG - should be 0xA0!)
- Later boots: mtvec=0x673C or 0xA0 (correct values)

This is CRITICAL because:
- crt0.s sets mtvec via: la t0, _early_trap_handler; csrw mtvec, t0
- _early_trap_handler should be at 0xA0 (confirmed from later boots)
- But first boot shows mtvec=0x00000004!

The value 0x00000004 is suspicious - it's the address of the SECOND instruction
of the `la` sequence (the addi part). This suggests either:
1. The auipc put PC into t0 incorrectly (PC=0x04 when it should be 0x00)
2. The csrw executed before addi completed (pipeline bug)
3. Something overwrote mtvec after it was set

AUIPC implementation check (cpu_core.v line 259):
    wire [31:0] id_auipc_value = id_pc + imm_U;
This uses id_pc which SHOULD be the PC of the auipc instruction itself.
But if there's a pipeline hazard or timing issue, id_pc might be wrong.

================================================================================
NEXT STEPS TO TRY:
================================================================================

1. [DONE] Add debug print in crt0.s IMMEDIATELY after csrw mtvec to verify the value
   - Added [MTVEC=0xXXXXXXXX] print right after setting up stack pointer
2. [ ] Check if auipc uses the correct PC value (id_pc vs if_pc)
3. [ ] Add debug prints in pxPortInitialiseStack to show what mepc value is stored
4. [ ] Check if there's a pipeline hazard between auipc/addi/csrw sequence
5. [ ] Verify _early_trap_handler address matches 0xA0

================================================================================
BUILD COMPLETED: Dec 5, 2025 - 9:28 AM
================================================================================

CONFIRMED BUG: [MTVEC=0x00000004] proves DATA HAZARD in CPU!
- crt0.s sets mtvec via: la t0, handler; csrw mtvec, t0
- csrw reads STALE t0 value (0x04 = address of addi instruction!)
- CPU has NO STALL for non-forwardable instructions (auipc, lui, etc.)

================================================================================
ATTEMPTED FIX #1: Add load_use_hazard stall (REVERTED)
================================================================================

Applied to cpu_core.v:
- Added load_use_hazard detection for auipc/lui/jal/jalr/load/csr
- Added load_use_hazard to pipeline_stall signal
- Intended to stall 1 cycle when ID-stage reads EX-stage rd of non-forwardable instr

RESULT: DID NOT FIX!
- mtvec still shows 0x00000004 in simulation output
- ecalls disappeared from output (different behavior, but still broken)
- PC stuck in small loop (0x170-0x17c)

ANALYSIS: This stall was WRONG because it conflicts with the WB forwarding mechanism!

================================================================================
KEY DISCOVERY: srv32-style WB forwarding
================================================================================

After analyzing the code compared to srv32 reference:

1. Regfile has NO internal forwarding (reads are combinatorial, writes on posedge)

2. BUT the "WB" signals are COMBINATORIAL from EX stage (not a separate registered stage):
   - wire mem_we = ex_we;
   - wire wb_we = mem_we;
   - wire wb_wdata = wb_value_pre; (includes ex_auipc_value for auipc!)

3. This means WB forwarding WORKS for auipc/lui/load without stalling!
   When auipc is in EX and addi needs t0:
   - forward_wb_rs1 = 1 (because wb_we = ex_we = 1)
   - op1 = wb_wdata = ex_auipc_value = correct value!

4. The original srv32 code had: wire load_use_hazard = 1'b0;  // DISABLED
   My stall was INTERFERING with the normal WB forwarding timing!

FIX: Reverted to original srv32 approach - disabled load_use_hazard
- Changed back to: wire load_use_hazard = 1'b0;

================================================================================
BUT WHY IS mtvec = 0x04 STILL?
================================================================================

If WB forwarding works, why does csrw get wrong value?

The value 0x04 is specifically the PC of the addi instruction.
Possible causes still being investigated:
1. WB forwarding might have a bug for CSR instructions specifically
2. CSR op1 might be captured at wrong time
3. There might be a reset/initialization issue in first few cycles
4. The id_auipc_value might be computed with wrong id_pc value

Need to add waveform/debug output to trace actual signal values during first 10 cycles.

================================================================================
FIX #2: RESET RACE CONDITION (Dec 5, 2025)
================================================================================

FOUND THE ROOT CAUSE!

pc_reg.v used SYNCHRONOUS reset:
    always @(posedge clk) begin        // ← NO async reset!
        if (!rst_n) begin
            pc <= 32'b0;

if_id.v used ASYNCHRONOUS reset:
    always @(posedge clk or negedge rst_n) begin   // ← HAS async reset!
        if (!rst_n) begin
            id_pc <= 32'b0;

THE BUG:
1. During reset (rst_n=0):
   - if_id holds id_pc=0 asynchronously
   - pc_reg waits for clock edge

2. First clock after reset release (rst_n=1):
   - pc_reg: rst_n=1, reset branch NOT taken → pc increments 0→4
   - if_id: latches if_pc = pc = 4 → id_pc = 4!

3. When auipc is decoded:
   - id_pc = 4 (WRONG! should be 0)
   - id_auipc_value = 4 + 0 = 4
   - t0 = 4, then mtvec = 4 ❌

FIX APPLIED:
Changed pc_reg.v from:
    always @(posedge clk) begin
To:
    always @(posedge clk or negedge rst_n) begin

This makes PC reset asynchronously, matching the pipeline latches.

================================================================================
FIX #3: INSTRUCTION FETCH DELAY BUG (Dec 5, 2025)
================================================================================

FOUND VIA DEBUG OUTPUT! The cycle-by-cycle trace showed:

[CYCLE 1] PC=0x00000004 id_pc=0x00000000 instr=0x00000297  <- auipc fetched twice!
[CYCLE 2] PC=0x00000008 id_pc=0x00000004 instr=0x30529073  <- addi SKIPPED!
[CYCLE 3] ex_auipc_val=0x00000004  <- WRONG! Should be 0!

THE BUG in cpu_top.v:
```verilog
wire instr_ready = (instr_fetch_delay == 2'd2);
wire [13:0] instr_idx = instr_ready ? pc[15:2] : 14'd0;  // Forces addr 0 for 2 cycles!
wire step_pulse = 1'b1;  // BUT PC KEEPS INCREMENTING!
```

During cycles 0-1:
- instr_fetch_delay < 2, so instr_idx forced to 0
- step_pulse = 1, so PC keeps incrementing (0 → 4 → 8)
- auipc is fetched from addr 0 in both cycles
- IF/ID latch captures: id_pc=4, id_inst=auipc
- auipc decoded with id_pc=4: id_auipc_value = 4 + 0 = 4 (WRONG!)
- addi at address 0x04 is NEVER FETCHED!

THE FIX:
Changed: wire step_pulse = 1'b1;
To:      wire step_pulse = instr_ready;

This stalls the CPU during the first 2 cycles until instruction fetch is ready.

================================================================================
RESULTS (Dec 5, 2025):
================================================================================
mtvec=0x00000130 on first boot! ✓ BUG FIXED!

Both fixes were required:
1. pc_reg.v: async reset (or negedge rst_n in sensitivity list)
2. cpu_top.v: step_pulse = instr_ready (stall during fetch delay)

================================================================================
FIX #4: TESTBENCH FALSE POSITIVE BUG (Dec 5, 2025)
================================================================================

FOUND THE ISSUE WITH mepc=0x354 "ECALL" MYSTERY!

The testbench was detecting trap entry by watching csr_mepc changes:
    if (dut.u_cpu.csr_mepc != last_mepc && dut.u_cpu.csr_mepc != 0)

THE BUG: This fires TWICE for each trap:
1. Trap ENTRY: mepc = ecall_address, mcause = 0xB
2. Trap EXIT: csrw mepc, (ecall_address + 4) → mcause STILL 0xB!

So mepc=0x354 was actually (original_ecall + 4), and we were detecting
the trap handler's "csrw mepc" instruction, not a real trap!

FIX APPLIED:
Changed tb_cpu.sv to detect trap by PC jumping to mtvec:
    if (current_pc == dut.u_cpu.csr_mtvec && last_pc != dut.u_cpu.csr_mtvec)

This only fires when PC actually jumps to the trap handler.

================================================================================
SIMULATION RESULTS (Dec 5, 2025 - After Testbench Fix):
================================================================================

With fixed testbench (detecting PC→mtvec instead of mepc changes):

1. [MEPC=0x00000390] - Debug output from xPortStartFirstTask shows:
   - Task's saved mepc = 0x390 = vHeartbeatTask (CORRECT!)
   - The stack frame has the right task entry point

2. ecalls at 0x35e8 - These are REAL ecalls (verified with objdump):
   - 0x35e8 contains "ecall" instruction in xTaskResumeAll.part.0
   - FreeRTOS kernel uses portYIELD() = ecall for context switches
   - These are NORMAL behavior during task creation

3. Timer interrupts show mepc=0x00000004 - THIS IS THE BUG!
   - After mret, CPU should be at 0x390 (vHeartbeatTask)
   - But timer catches CPU at 0x04 (near reset vector!)
   - This means mret is NOT jumping to mepc correctly

================================================================================
CURRENT HYPOTHESIS: MRET NOT USING CORRECT MEPC
================================================================================

The sequence should be:
1. xPortStartFirstTask writes mepc=0x390 via "csrw mepc, t0"
2. Register restores happen (30+ instructions)
3. mret executes, should jump to 0x390
4. Timer interrupt fires, mepc should be ~0x390

But we see:
1. [MEPC=0x390] debug print (stack value is correct)
2. Timer interrupt mepc=0x04 (CPU at wrong location!)

Possible causes:
A) csrw mepc is not actually writing the value (flushed? wrong data?)
B) Something overwrites csr_mepc between csrw and mret (unexpected trap?)
C) mret branch_target is not being used (hardware bug?)

================================================================================
FIX #5: ADDED MRET/CSRW DEBUG TO TESTBENCH (Dec 5, 2025)
================================================================================

Added to tb_cpu.sv:
- [MRET] debug: prints when mret instruction detected in ID stage
  Shows: PC, csr_mepc value, mstatus value
- [CSRW MEPC] debug: prints when csrw to mepc (0x341) detected
  Will show the exact moment mepc CSR is being written

This will help identify:
1. What value csr_mepc has when mret executes
2. Whether csrw mepc is actually executing
3. If something corrupts mepc between csrw and mret

================================================================================
DETAILED ANALYSIS (Dec 5, 2025):
================================================================================

HDL Code Review - Branch Target Priority:
```verilog
assign branch_target =
    misaligned_trap ? branch_target_trap :   // Priority 1
    trap_flush      ? branch_target_trap :   // Priority 2
    mret_flush      ? branch_target_mret :   // Priority 3 - SHOULD WIN
    branch_flush    ? branch_target_ex :     // Priority 4
                      32'b0;
```

Interrupt Blocking Logic:
```verilog
wire system_op_in_pipeline = ex_is_csr | is_ecall | is_ebreak | is_mret;
wire irq_take = timer_irq_level && csr_mstatus_mie && csr_mie_mtie && !system_op_in_pipeline;
```

When mret is in ID:
- is_mret = 1 → system_op_in_pipeline = 1 → irq_take = 0 ✓
- mret_flush = 1, trap_flush = 0 → branch_target = csr_mepc = 0x390 ✓
- On posedge: PC → 0x390, MIE → 1 (MPIE)

POTENTIAL BUG: What happens on cycle N+1 AFTER mret?
- MIE is now 1 (just set by mret)
- If timer_irq_level = 1 and pipeline has no system_op...
- irq_take = 1! trap_flush = 1!
- But what's the PC at this point?

If the pipeline flush from mret creates a bubble, and the interrupt fires
while the new instruction (at 0x390) is being fetched, the mepc would be
set to some intermediate value!

================================================================================
FIX #6: COMPREHENSIVE MRET DEBUG (Dec 5, 2025)
================================================================================

Added to tb_cpu.sv:
- Print mret_flush, trap_flush, branch_flush signals
- Print irq_take, timer_irq, mstatus_mie, system_op signals  
- Print branch_flag and branch_target values
- Track PC for cycles after mret to see where it actually goes

================================================================================
ROOT CAUSE FOUND! (Dec 5, 2025)
================================================================================

Debug output revealed:
```
[MRET] branch_target=0x00000390                    ← CORRECT!
[POST-MRET] PC=0x00000390 irq_take=1 trap_flush=1  ← PC correct, but IRQ fires!
[INT] Timer interrupt #0, mepc=0x00000004          ← mepc WRONG!
```

THE BUG: mret WORKS correctly (PC=0x390), but interrupt mepc save is broken!

When interrupt fires immediately after mret:
- PC = 0x390 (correct - mret jumped here)
- ID stage has BUBBLE (pipeline just flushed!)
- id_pc = STALE DATA (probably 0x00 from flush)
- mepc = id_pc + 4 = 0x04 (WRONG!)

The interrupt handler then returns to 0x04 instead of 0x390!

================================================================================
FIX #7: INTERRUPT MEPC SAVE BUG (Dec 5, 2025)
================================================================================

Changed cpu_core.v line 674:
```verilog
// OLD (BUG): id_pc is stale after pipeline flush!
csr_mepc <= irq_take ? (id_pc + 32'd4) : id_pc;

// NEW (FIX): Use actual PC being fetched for interrupts
csr_mepc <= irq_take ? pc : id_pc;
```

For interrupts: save `pc` (the PC being fetched, which is correct)
For ecall/ebreak: save `id_pc` (the instruction that caused exception)

================================================================================
NEXT STEPS:
================================================================================
1. [ ] Rebuild simulation with fixed interrupt mepc save
2. [ ] Verify timer interrupt now saves mepc=0x390 (not 0x04)
3. [ ] Check if heartbeat task runs after context switch

================================================================================
ECALLS DURING TASK CREATION:
================================================================================

The ecalls at 0x35ac and 0x35b0 are from FreeRTOS kernel:
- FreeRTOS uses portYIELD() = ecall for context switches
- During task creation, kernel enters/exits critical sections
- With broken mtvec, ecall jumps to wrong address causing chaos!
- ONCE MTVEC BUG IS FIXED, ecalls will go to proper trap handler

================================================================================
To run simulation:
  cd C:\Users\evanw\FPGA_CPU1\FPGA_CPU1.sim\sim_1\behav\xsim
  .\sim_top.bat

================================================================================
